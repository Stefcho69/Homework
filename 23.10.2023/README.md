# 1
 Направете object-like макро, което да улеснява дефинирането на масив от 5 елемента, и което да се използва за да се принтират елементите от масива

# 2
Направете function-like макро, което да използва троичния оператор за сравнение за да намира по-големия от 2 елемента.

# 3
Направете макро, което да дефинира помощен инструмент за дебъгване, който да принтира името на променливата, нейната стойност файлът в който се използва и линията от код, която принтира тази информация.

# 4
Дефинирайте макро функция, която да се казва COMMAND да приема два аргумента NAME и TYPE и да създава идентификатор за командна функция от типа TYPE_NAME_command. Така например COMMAND(quit, internal) да създава идентификатор internal_quit_command. Направете макро функция която да се казва DEFINE_COMMAND, която да приема два аргумента NAME и TYPE и да използва макрото COMMAND за да създаде декларация на функция от типа “void TYPE_NAME_command(void)” така например DEFINE_COMMAND(quit, external) { … } трябва да създаде дефиниция на функция “void external_quit_command(void) {...}”. Използвайте макрото за да дефинирате две функции, които да принтират просто съобщение на екрана. Извикайте тези функции в main.

# 5
Направете макро функция (SWAP(А, B, TYPE)), което да разменя стойностите на две променливи от произволен тип. Помощ: въведете типа като допълнителен аргумент на макро функцията. Демонстрирайте използването на подобно макро. Когато дефинирате макрото за да се чете по лесно кодът, можете да слагата “\” за да направите макрото на няколко реда.

# 6
Направете макро функция, която да сортира масив от произволен тип, и да може да сортира низходящо или възходящо в зависимост от аргумент, подаден на макрото. Пример за дефиниция на подобно макро функция SORT(ARRAY, SIZE, TYPE, COMPARE). Пример за използване на подобна макро функция: SORT(array, 5, int, >). Хубаво е да се преизползва SWAP макро функцията от задача 5. Когато дефинирате макрото за да се чете по лесно кодът, можете да слагата “\” за да направите макрото на няколко реда..